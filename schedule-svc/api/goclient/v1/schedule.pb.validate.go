// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: schedule.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on UserScheduleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserScheduleResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserScheduleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserScheduleResponseMultiError, or nil if none found.
func (m *UserScheduleResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UserScheduleResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Class

	// no validation rules for PhotoSrc

	// no validation rules for Role

	// no validation rules for Name

	// no validation rules for Email

	if m.Major != nil {
		// no validation rules for Major
	}

	if m.Phone != nil {
		// no validation rules for Phone
	}

	if len(errors) > 0 {
		return UserScheduleResponseMultiError(errors)
	}

	return nil
}

// UserScheduleResponseMultiError is an error wrapping multiple validation
// errors returned by UserScheduleResponse.ValidateAll() if the designated
// constraints aren't met.
type UserScheduleResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserScheduleResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserScheduleResponseMultiError) AllErrors() []error { return m }

// UserScheduleResponseValidationError is the validation error returned by
// UserScheduleResponse.Validate if the designated constraints aren't met.
type UserScheduleResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserScheduleResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserScheduleResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserScheduleResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserScheduleResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserScheduleResponseValidationError) ErrorName() string {
	return "UserScheduleResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UserScheduleResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserScheduleResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserScheduleResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserScheduleResponseValidationError{}

// Validate checks the field values on StudentDefScheduleResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StudentDefScheduleResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StudentDefScheduleResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StudentDefScheduleResponseMultiError, or nil if none found.
func (m *StudentDefScheduleResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *StudentDefScheduleResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetInfor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StudentDefScheduleResponseValidationError{
					field:  "Infor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StudentDefScheduleResponseValidationError{
					field:  "Infor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInfor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StudentDefScheduleResponseValidationError{
				field:  "Infor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInstructor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StudentDefScheduleResponseValidationError{
					field:  "Instructor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StudentDefScheduleResponseValidationError{
					field:  "Instructor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInstructor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StudentDefScheduleResponseValidationError{
				field:  "Instructor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StudentDefScheduleResponseValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StudentDefScheduleResponseValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StudentDefScheduleResponseValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return StudentDefScheduleResponseMultiError(errors)
	}

	return nil
}

// StudentDefScheduleResponseMultiError is an error wrapping multiple
// validation errors returned by StudentDefScheduleResponse.ValidateAll() if
// the designated constraints aren't met.
type StudentDefScheduleResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StudentDefScheduleResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StudentDefScheduleResponseMultiError) AllErrors() []error { return m }

// StudentDefScheduleResponseValidationError is the validation error returned
// by StudentDefScheduleResponse.Validate if the designated constraints aren't met.
type StudentDefScheduleResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StudentDefScheduleResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StudentDefScheduleResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StudentDefScheduleResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StudentDefScheduleResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StudentDefScheduleResponseValidationError) ErrorName() string {
	return "StudentDefScheduleResponseValidationError"
}

// Error satisfies the builtin error interface
func (e StudentDefScheduleResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStudentDefScheduleResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StudentDefScheduleResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StudentDefScheduleResponseValidationError{}

// Validate checks the field values on TimeSlot with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TimeSlot) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TimeSlot with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TimeSlotMultiError, or nil
// if none found.
func (m *TimeSlot) ValidateAll() error {
	return m.validate(true)
}

func (m *TimeSlot) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Date

	// no validation rules for Shift

	// no validation rules for Id

	// no validation rules for Time

	if len(errors) > 0 {
		return TimeSlotMultiError(errors)
	}

	return nil
}

// TimeSlotMultiError is an error wrapping multiple validation errors returned
// by TimeSlot.ValidateAll() if the designated constraints aren't met.
type TimeSlotMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TimeSlotMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TimeSlotMultiError) AllErrors() []error { return m }

// TimeSlotValidationError is the validation error returned by
// TimeSlot.Validate if the designated constraints aren't met.
type TimeSlotValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TimeSlotValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TimeSlotValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TimeSlotValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TimeSlotValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TimeSlotValidationError) ErrorName() string { return "TimeSlotValidationError" }

// Error satisfies the builtin error interface
func (e TimeSlotValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTimeSlot.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TimeSlotValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TimeSlotValidationError{}

// Validate checks the field values on RoomSchedule with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RoomSchedule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RoomSchedule with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RoomScheduleMultiError, or
// nil if none found.
func (m *RoomSchedule) ValidateAll() error {
	return m.validate(true)
}

func (m *RoomSchedule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for School

	// no validation rules for Type

	// no validation rules for Description

	// no validation rules for CreatedAt

	if len(errors) > 0 {
		return RoomScheduleMultiError(errors)
	}

	return nil
}

// RoomScheduleMultiError is an error wrapping multiple validation errors
// returned by RoomSchedule.ValidateAll() if the designated constraints aren't met.
type RoomScheduleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RoomScheduleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RoomScheduleMultiError) AllErrors() []error { return m }

// RoomScheduleValidationError is the validation error returned by
// RoomSchedule.Validate if the designated constraints aren't met.
type RoomScheduleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RoomScheduleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RoomScheduleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RoomScheduleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RoomScheduleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RoomScheduleValidationError) ErrorName() string { return "RoomScheduleValidationError" }

// Error satisfies the builtin error interface
func (e RoomScheduleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRoomSchedule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RoomScheduleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RoomScheduleValidationError{}

// Validate checks the field values on TimeSlots with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TimeSlots) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TimeSlots with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TimeSlotsMultiError, or nil
// if none found.
func (m *TimeSlots) ValidateAll() error {
	return m.validate(true)
}

func (m *TimeSlots) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStudent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TimeSlotsValidationError{
					field:  "Student",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TimeSlotsValidationError{
					field:  "Student",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStudent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TimeSlotsValidationError{
				field:  "Student",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTimeSlot()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TimeSlotsValidationError{
					field:  "TimeSlot",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TimeSlotsValidationError{
					field:  "TimeSlot",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeSlot()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TimeSlotsValidationError{
				field:  "TimeSlot",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TimeSlotsMultiError(errors)
	}

	return nil
}

// TimeSlotsMultiError is an error wrapping multiple validation errors returned
// by TimeSlots.ValidateAll() if the designated constraints aren't met.
type TimeSlotsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TimeSlotsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TimeSlotsMultiError) AllErrors() []error { return m }

// TimeSlotsValidationError is the validation error returned by
// TimeSlots.Validate if the designated constraints aren't met.
type TimeSlotsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TimeSlotsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TimeSlotsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TimeSlotsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TimeSlotsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TimeSlotsValidationError) ErrorName() string { return "TimeSlotsValidationError" }

// Error satisfies the builtin error interface
func (e TimeSlotsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTimeSlots.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TimeSlotsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TimeSlotsValidationError{}

// Validate checks the field values on Schedule with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Schedule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Schedule with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ScheduleMultiError, or nil
// if none found.
func (m *Schedule) ValidateAll() error {
	return m.validate(true)
}

func (m *Schedule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTimeSlots() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ScheduleValidationError{
						field:  fmt.Sprintf("TimeSlots[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ScheduleValidationError{
						field:  fmt.Sprintf("TimeSlots[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ScheduleValidationError{
					field:  fmt.Sprintf("TimeSlots[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetRoom()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ScheduleValidationError{
					field:  "Room",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ScheduleValidationError{
					field:  "Room",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRoom()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ScheduleValidationError{
				field:  "Room",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ScheduleMultiError(errors)
	}

	return nil
}

// ScheduleMultiError is an error wrapping multiple validation errors returned
// by Schedule.ValidateAll() if the designated constraints aren't met.
type ScheduleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScheduleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScheduleMultiError) AllErrors() []error { return m }

// ScheduleValidationError is the validation error returned by
// Schedule.Validate if the designated constraints aren't met.
type ScheduleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScheduleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScheduleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScheduleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScheduleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScheduleValidationError) ErrorName() string { return "ScheduleValidationError" }

// Error satisfies the builtin error interface
func (e ScheduleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSchedule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScheduleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScheduleValidationError{}

// Validate checks the field values on Thesis with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Thesis) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Thesis with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ThesisMultiError, or nil if none found.
func (m *Thesis) ValidateAll() error {
	return m.validate(true)
}

func (m *Thesis) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSchedule()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ThesisValidationError{
					field:  "Schedule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ThesisValidationError{
					field:  "Schedule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSchedule()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ThesisValidationError{
				field:  "Schedule",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetCouncil() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ThesisValidationError{
						field:  fmt.Sprintf("Council[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ThesisValidationError{
						field:  fmt.Sprintf("Council[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ThesisValidationError{
					field:  fmt.Sprintf("Council[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Id

	if len(errors) > 0 {
		return ThesisMultiError(errors)
	}

	return nil
}

// ThesisMultiError is an error wrapping multiple validation errors returned by
// Thesis.ValidateAll() if the designated constraints aren't met.
type ThesisMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ThesisMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ThesisMultiError) AllErrors() []error { return m }

// ThesisValidationError is the validation error returned by Thesis.Validate if
// the designated constraints aren't met.
type ThesisValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ThesisValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ThesisValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ThesisValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ThesisValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ThesisValidationError) ErrorName() string { return "ThesisValidationError" }

// Error satisfies the builtin error interface
func (e ThesisValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sThesis.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ThesisValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ThesisValidationError{}

// Validate checks the field values on ScheduleResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ScheduleResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ScheduleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ScheduleResponseMultiError, or nil if none found.
func (m *ScheduleResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ScheduleResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetThesis()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ScheduleResponseValidationError{
					field:  "Thesis",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ScheduleResponseValidationError{
					field:  "Thesis",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetThesis()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ScheduleResponseValidationError{
				field:  "Thesis",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ScheduleResponseValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ScheduleResponseValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ScheduleResponseValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ScheduleResponseMultiError(errors)
	}

	return nil
}

// ScheduleResponseMultiError is an error wrapping multiple validation errors
// returned by ScheduleResponse.ValidateAll() if the designated constraints
// aren't met.
type ScheduleResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScheduleResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScheduleResponseMultiError) AllErrors() []error { return m }

// ScheduleResponseValidationError is the validation error returned by
// ScheduleResponse.Validate if the designated constraints aren't met.
type ScheduleResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScheduleResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScheduleResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScheduleResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScheduleResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScheduleResponseValidationError) ErrorName() string { return "ScheduleResponseValidationError" }

// Error satisfies the builtin error interface
func (e ScheduleResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScheduleResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScheduleResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScheduleResponseValidationError{}

// Validate checks the field values on GetSchedulesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSchedulesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSchedulesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSchedulesRequestMultiError, or nil if none found.
func (m *GetSchedulesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSchedulesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetSchedulesRequestMultiError(errors)
	}

	return nil
}

// GetSchedulesRequestMultiError is an error wrapping multiple validation
// errors returned by GetSchedulesRequest.ValidateAll() if the designated
// constraints aren't met.
type GetSchedulesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSchedulesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSchedulesRequestMultiError) AllErrors() []error { return m }

// GetSchedulesRequestValidationError is the validation error returned by
// GetSchedulesRequest.Validate if the designated constraints aren't met.
type GetSchedulesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSchedulesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSchedulesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSchedulesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSchedulesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSchedulesRequestValidationError) ErrorName() string {
	return "GetSchedulesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetSchedulesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSchedulesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSchedulesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSchedulesRequestValidationError{}

// Validate checks the field values on GetSchedulesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSchedulesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSchedulesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSchedulesResponseMultiError, or nil if none found.
func (m *GetSchedulesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSchedulesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	for idx, item := range m.GetThesis() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetSchedulesResponseValidationError{
						field:  fmt.Sprintf("Thesis[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetSchedulesResponseValidationError{
						field:  fmt.Sprintf("Thesis[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetSchedulesResponseValidationError{
					field:  fmt.Sprintf("Thesis[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetSchedulesResponseMultiError(errors)
	}

	return nil
}

// GetSchedulesResponseMultiError is an error wrapping multiple validation
// errors returned by GetSchedulesResponse.ValidateAll() if the designated
// constraints aren't met.
type GetSchedulesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSchedulesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSchedulesResponseMultiError) AllErrors() []error { return m }

// GetSchedulesResponseValidationError is the validation error returned by
// GetSchedulesResponse.Validate if the designated constraints aren't met.
type GetSchedulesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSchedulesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSchedulesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSchedulesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSchedulesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSchedulesResponseValidationError) ErrorName() string {
	return "GetSchedulesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetSchedulesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSchedulesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSchedulesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSchedulesResponseValidationError{}

// Validate checks the field values on CreateScheduleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateScheduleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateScheduleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateScheduleRequestMultiError, or nil if none found.
func (m *CreateScheduleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateScheduleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for StartDate

	// no validation rules for QuantityWeek

	for idx, item := range m.GetRooms() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateScheduleRequestValidationError{
						field:  fmt.Sprintf("Rooms[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateScheduleRequestValidationError{
						field:  fmt.Sprintf("Rooms[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateScheduleRequestValidationError{
					field:  fmt.Sprintf("Rooms[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetCouncils() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateScheduleRequestValidationError{
						field:  fmt.Sprintf("Councils[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateScheduleRequestValidationError{
						field:  fmt.Sprintf("Councils[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateScheduleRequestValidationError{
					field:  fmt.Sprintf("Councils[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetStudentDefs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateScheduleRequestValidationError{
						field:  fmt.Sprintf("StudentDefs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateScheduleRequestValidationError{
						field:  fmt.Sprintf("StudentDefs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateScheduleRequestValidationError{
					field:  fmt.Sprintf("StudentDefs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateScheduleRequestMultiError(errors)
	}

	return nil
}

// CreateScheduleRequestMultiError is an error wrapping multiple validation
// errors returned by CreateScheduleRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateScheduleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateScheduleRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateScheduleRequestMultiError) AllErrors() []error { return m }

// CreateScheduleRequestValidationError is the validation error returned by
// CreateScheduleRequest.Validate if the designated constraints aren't met.
type CreateScheduleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateScheduleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateScheduleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateScheduleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateScheduleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateScheduleRequestValidationError) ErrorName() string {
	return "CreateScheduleRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateScheduleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateScheduleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateScheduleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateScheduleRequestValidationError{}

// Validate checks the field values on CreateScheduleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateScheduleResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateScheduleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateScheduleResponseMultiError, or nil if none found.
func (m *CreateScheduleResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateScheduleResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	for idx, item := range m.GetThesis() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateScheduleResponseValidationError{
						field:  fmt.Sprintf("Thesis[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateScheduleResponseValidationError{
						field:  fmt.Sprintf("Thesis[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateScheduleResponseValidationError{
					field:  fmt.Sprintf("Thesis[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateScheduleResponseMultiError(errors)
	}

	return nil
}

// CreateScheduleResponseMultiError is an error wrapping multiple validation
// errors returned by CreateScheduleResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateScheduleResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateScheduleResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateScheduleResponseMultiError) AllErrors() []error { return m }

// CreateScheduleResponseValidationError is the validation error returned by
// CreateScheduleResponse.Validate if the designated constraints aren't met.
type CreateScheduleResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateScheduleResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateScheduleResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateScheduleResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateScheduleResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateScheduleResponseValidationError) ErrorName() string {
	return "CreateScheduleResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateScheduleResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateScheduleResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateScheduleResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateScheduleResponseValidationError{}

// Validate checks the field values on Notification with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Notification) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Notification with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NotificationMultiError, or
// nil if none found.
func (m *Notification) ValidateAll() error {
	return m.validate(true)
}

func (m *Notification) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetSenderUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NotificationValidationError{
					field:  "SenderUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NotificationValidationError{
					field:  "SenderUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSenderUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NotificationValidationError{
				field:  "SenderUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetReceiverAuthor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NotificationValidationError{
					field:  "ReceiverAuthor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NotificationValidationError{
					field:  "ReceiverAuthor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReceiverAuthor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NotificationValidationError{
				field:  "ReceiverAuthor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NotificationValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NotificationValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NotificationValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NotificationMultiError(errors)
	}

	return nil
}

// NotificationMultiError is an error wrapping multiple validation errors
// returned by Notification.ValidateAll() if the designated constraints aren't met.
type NotificationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NotificationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NotificationMultiError) AllErrors() []error { return m }

// NotificationValidationError is the validation error returned by
// Notification.Validate if the designated constraints aren't met.
type NotificationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NotificationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NotificationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NotificationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NotificationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NotificationValidationError) ErrorName() string { return "NotificationValidationError" }

// Error satisfies the builtin error interface
func (e NotificationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNotification.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NotificationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NotificationValidationError{}

// Validate checks the field values on GetNotificationsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetNotificationsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetNotificationsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetNotificationsRequestMultiError, or nil if none found.
func (m *GetNotificationsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetNotificationsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetNotificationsRequestMultiError(errors)
	}

	return nil
}

// GetNotificationsRequestMultiError is an error wrapping multiple validation
// errors returned by GetNotificationsRequest.ValidateAll() if the designated
// constraints aren't met.
type GetNotificationsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetNotificationsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetNotificationsRequestMultiError) AllErrors() []error { return m }

// GetNotificationsRequestValidationError is the validation error returned by
// GetNotificationsRequest.Validate if the designated constraints aren't met.
type GetNotificationsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetNotificationsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetNotificationsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetNotificationsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetNotificationsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetNotificationsRequestValidationError) ErrorName() string {
	return "GetNotificationsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetNotificationsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetNotificationsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetNotificationsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetNotificationsRequestValidationError{}

// Validate checks the field values on GetNotificationsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetNotificationsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetNotificationsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetNotificationsResponseMultiError, or nil if none found.
func (m *GetNotificationsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetNotificationsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetNotifications() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetNotificationsResponseValidationError{
						field:  fmt.Sprintf("Notifications[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetNotificationsResponseValidationError{
						field:  fmt.Sprintf("Notifications[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetNotificationsResponseValidationError{
					field:  fmt.Sprintf("Notifications[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetNotificationsResponseMultiError(errors)
	}

	return nil
}

// GetNotificationsResponseMultiError is an error wrapping multiple validation
// errors returned by GetNotificationsResponse.ValidateAll() if the designated
// constraints aren't met.
type GetNotificationsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetNotificationsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetNotificationsResponseMultiError) AllErrors() []error { return m }

// GetNotificationsResponseValidationError is the validation error returned by
// GetNotificationsResponse.Validate if the designated constraints aren't met.
type GetNotificationsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetNotificationsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetNotificationsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetNotificationsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetNotificationsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetNotificationsResponseValidationError) ErrorName() string {
	return "GetNotificationsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetNotificationsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetNotificationsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetNotificationsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetNotificationsResponseValidationError{}

// Validate checks the field values on CreateNotificationRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateNotificationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateNotificationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateNotificationRequestMultiError, or nil if none found.
func (m *CreateNotificationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateNotificationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNoti()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNotificationRequestValidationError{
					field:  "Noti",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNotificationRequestValidationError{
					field:  "Noti",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNoti()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNotificationRequestValidationError{
				field:  "Noti",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateNotificationRequestMultiError(errors)
	}

	return nil
}

// CreateNotificationRequestMultiError is an error wrapping multiple validation
// errors returned by CreateNotificationRequest.ValidateAll() if the
// designated constraints aren't met.
type CreateNotificationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateNotificationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateNotificationRequestMultiError) AllErrors() []error { return m }

// CreateNotificationRequestValidationError is the validation error returned by
// CreateNotificationRequest.Validate if the designated constraints aren't met.
type CreateNotificationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateNotificationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateNotificationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateNotificationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateNotificationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateNotificationRequestValidationError) ErrorName() string {
	return "CreateNotificationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateNotificationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateNotificationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateNotificationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateNotificationRequestValidationError{}

// Validate checks the field values on CreateNotificationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateNotificationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateNotificationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateNotificationResponseMultiError, or nil if none found.
func (m *CreateNotificationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateNotificationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNotification()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateNotificationResponseValidationError{
					field:  "Notification",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateNotificationResponseValidationError{
					field:  "Notification",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNotification()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateNotificationResponseValidationError{
				field:  "Notification",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Message

	for idx, item := range m.GetNotifications() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateNotificationResponseValidationError{
						field:  fmt.Sprintf("Notifications[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateNotificationResponseValidationError{
						field:  fmt.Sprintf("Notifications[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateNotificationResponseValidationError{
					field:  fmt.Sprintf("Notifications[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateNotificationResponseMultiError(errors)
	}

	return nil
}

// CreateNotificationResponseMultiError is an error wrapping multiple
// validation errors returned by CreateNotificationResponse.ValidateAll() if
// the designated constraints aren't met.
type CreateNotificationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateNotificationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateNotificationResponseMultiError) AllErrors() []error { return m }

// CreateNotificationResponseValidationError is the validation error returned
// by CreateNotificationResponse.Validate if the designated constraints aren't met.
type CreateNotificationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateNotificationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateNotificationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateNotificationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateNotificationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateNotificationResponseValidationError) ErrorName() string {
	return "CreateNotificationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateNotificationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateNotificationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateNotificationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateNotificationResponseValidationError{}

// Validate checks the field values on AssessItem with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AssessItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AssessItem with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AssessItemMultiError, or
// nil if none found.
func (m *AssessItem) ValidateAll() error {
	return m.validate(true)
}

func (m *AssessItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetLecturer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssessItemValidationError{
					field:  "Lecturer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssessItemValidationError{
					field:  "Lecturer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLecturer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssessItemValidationError{
				field:  "Lecturer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Point

	// no validation rules for Comment

	if len(errors) > 0 {
		return AssessItemMultiError(errors)
	}

	return nil
}

// AssessItemMultiError is an error wrapping multiple validation errors
// returned by AssessItem.ValidateAll() if the designated constraints aren't met.
type AssessItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AssessItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AssessItemMultiError) AllErrors() []error { return m }

// AssessItemValidationError is the validation error returned by
// AssessItem.Validate if the designated constraints aren't met.
type AssessItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AssessItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AssessItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AssessItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AssessItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AssessItemValidationError) ErrorName() string { return "AssessItemValidationError" }

// Error satisfies the builtin error interface
func (e AssessItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAssessItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AssessItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AssessItemValidationError{}

// Validate checks the field values on Point with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Point) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Point with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PointMultiError, or nil if none found.
func (m *Point) ValidateAll() error {
	return m.validate(true)
}

func (m *Point) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetStudent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PointValidationError{
					field:  "Student",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PointValidationError{
					field:  "Student",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStudent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PointValidationError{
				field:  "Student",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetAssesses() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PointValidationError{
						field:  fmt.Sprintf("Assesses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PointValidationError{
						field:  fmt.Sprintf("Assesses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PointValidationError{
					field:  fmt.Sprintf("Assesses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PointMultiError(errors)
	}

	return nil
}

// PointMultiError is an error wrapping multiple validation errors returned by
// Point.ValidateAll() if the designated constraints aren't met.
type PointMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PointMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PointMultiError) AllErrors() []error { return m }

// PointValidationError is the validation error returned by Point.Validate if
// the designated constraints aren't met.
type PointValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PointValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PointValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PointValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PointValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PointValidationError) ErrorName() string { return "PointValidationError" }

// Error satisfies the builtin error interface
func (e PointValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPoint.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PointValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PointValidationError{}

// Validate checks the field values on CreateOrUpdatePointDefRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateOrUpdatePointDefRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateOrUpdatePointDefRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateOrUpdatePointDefRequestMultiError, or nil if none found.
func (m *CreateOrUpdatePointDefRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateOrUpdatePointDefRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPoint()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateOrUpdatePointDefRequestValidationError{
					field:  "Point",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateOrUpdatePointDefRequestValidationError{
					field:  "Point",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPoint()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateOrUpdatePointDefRequestValidationError{
				field:  "Point",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateOrUpdatePointDefRequestMultiError(errors)
	}

	return nil
}

// CreateOrUpdatePointDefRequestMultiError is an error wrapping multiple
// validation errors returned by CreateOrUpdatePointDefRequest.ValidateAll()
// if the designated constraints aren't met.
type CreateOrUpdatePointDefRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateOrUpdatePointDefRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateOrUpdatePointDefRequestMultiError) AllErrors() []error { return m }

// CreateOrUpdatePointDefRequestValidationError is the validation error
// returned by CreateOrUpdatePointDefRequest.Validate if the designated
// constraints aren't met.
type CreateOrUpdatePointDefRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateOrUpdatePointDefRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateOrUpdatePointDefRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateOrUpdatePointDefRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateOrUpdatePointDefRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateOrUpdatePointDefRequestValidationError) ErrorName() string {
	return "CreateOrUpdatePointDefRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateOrUpdatePointDefRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateOrUpdatePointDefRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateOrUpdatePointDefRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateOrUpdatePointDefRequestValidationError{}

// Validate checks the field values on CreateOrUpdatePointDefResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateOrUpdatePointDefResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateOrUpdatePointDefResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateOrUpdatePointDefResponseMultiError, or nil if none found.
func (m *CreateOrUpdatePointDefResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateOrUpdatePointDefResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPoint()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateOrUpdatePointDefResponseValidationError{
					field:  "Point",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateOrUpdatePointDefResponseValidationError{
					field:  "Point",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPoint()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateOrUpdatePointDefResponseValidationError{
				field:  "Point",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Message

	if len(errors) > 0 {
		return CreateOrUpdatePointDefResponseMultiError(errors)
	}

	return nil
}

// CreateOrUpdatePointDefResponseMultiError is an error wrapping multiple
// validation errors returned by CreateOrUpdatePointDefResponse.ValidateAll()
// if the designated constraints aren't met.
type CreateOrUpdatePointDefResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateOrUpdatePointDefResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateOrUpdatePointDefResponseMultiError) AllErrors() []error { return m }

// CreateOrUpdatePointDefResponseValidationError is the validation error
// returned by CreateOrUpdatePointDefResponse.Validate if the designated
// constraints aren't met.
type CreateOrUpdatePointDefResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateOrUpdatePointDefResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateOrUpdatePointDefResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateOrUpdatePointDefResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateOrUpdatePointDefResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateOrUpdatePointDefResponseValidationError) ErrorName() string {
	return "CreateOrUpdatePointDefResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateOrUpdatePointDefResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateOrUpdatePointDefResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateOrUpdatePointDefResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateOrUpdatePointDefResponseValidationError{}

// Validate checks the field values on GetAllPointDefsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAllPointDefsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAllPointDefsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAllPointDefsRequestMultiError, or nil if none found.
func (m *GetAllPointDefsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAllPointDefsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetAllPointDefsRequestMultiError(errors)
	}

	return nil
}

// GetAllPointDefsRequestMultiError is an error wrapping multiple validation
// errors returned by GetAllPointDefsRequest.ValidateAll() if the designated
// constraints aren't met.
type GetAllPointDefsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAllPointDefsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAllPointDefsRequestMultiError) AllErrors() []error { return m }

// GetAllPointDefsRequestValidationError is the validation error returned by
// GetAllPointDefsRequest.Validate if the designated constraints aren't met.
type GetAllPointDefsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAllPointDefsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAllPointDefsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAllPointDefsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAllPointDefsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAllPointDefsRequestValidationError) ErrorName() string {
	return "GetAllPointDefsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetAllPointDefsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAllPointDefsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAllPointDefsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAllPointDefsRequestValidationError{}

// Validate checks the field values on GetAllPointDefsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAllPointDefsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAllPointDefsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAllPointDefsResponseMultiError, or nil if none found.
func (m *GetAllPointDefsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAllPointDefsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetPoints() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetAllPointDefsResponseValidationError{
						field:  fmt.Sprintf("Points[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetAllPointDefsResponseValidationError{
						field:  fmt.Sprintf("Points[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetAllPointDefsResponseValidationError{
					field:  fmt.Sprintf("Points[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetAllPointDefsResponseMultiError(errors)
	}

	return nil
}

// GetAllPointDefsResponseMultiError is an error wrapping multiple validation
// errors returned by GetAllPointDefsResponse.ValidateAll() if the designated
// constraints aren't met.
type GetAllPointDefsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAllPointDefsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAllPointDefsResponseMultiError) AllErrors() []error { return m }

// GetAllPointDefsResponseValidationError is the validation error returned by
// GetAllPointDefsResponse.Validate if the designated constraints aren't met.
type GetAllPointDefsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAllPointDefsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAllPointDefsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAllPointDefsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAllPointDefsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAllPointDefsResponseValidationError) ErrorName() string {
	return "GetAllPointDefsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetAllPointDefsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAllPointDefsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAllPointDefsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAllPointDefsResponseValidationError{}
