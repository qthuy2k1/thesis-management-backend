// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: api_schedule.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on UserScheduleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserScheduleResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserScheduleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserScheduleResponseMultiError, or nil if none found.
func (m *UserScheduleResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UserScheduleResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if l := utf8.RuneCountInString(m.GetClass()); l < 4 || l > 10 {
		err := UserScheduleResponseValidationError{
			field:  "Class",
			reason: "value length must be between 4 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PhotoSrc

	if _, ok := _UserScheduleResponse_Role_InLookup[m.GetRole()]; !ok {
		err := UserScheduleResponseValidationError{
			field:  "Role",
			reason: "value must be in list [lecturer student admin]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 200 {
		err := UserScheduleResponseValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 200 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if err := m._validateEmail(m.GetEmail()); err != nil {
		err = UserScheduleResponseValidationError{
			field:  "Email",
			reason: "value must be a valid email address",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Major != nil {

		if utf8.RuneCountInString(m.GetMajor()) < 2 {
			err := UserScheduleResponseValidationError{
				field:  "Major",
				reason: "value length must be at least 2 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Phone != nil {

		if l := utf8.RuneCountInString(m.GetPhone()); l < 10 || l > 11 {
			err := UserScheduleResponseValidationError{
				field:  "Phone",
				reason: "value length must be between 10 and 11 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return UserScheduleResponseMultiError(errors)
	}

	return nil
}

func (m *UserScheduleResponse) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *UserScheduleResponse) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// UserScheduleResponseMultiError is an error wrapping multiple validation
// errors returned by UserScheduleResponse.ValidateAll() if the designated
// constraints aren't met.
type UserScheduleResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserScheduleResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserScheduleResponseMultiError) AllErrors() []error { return m }

// UserScheduleResponseValidationError is the validation error returned by
// UserScheduleResponse.Validate if the designated constraints aren't met.
type UserScheduleResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserScheduleResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserScheduleResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserScheduleResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserScheduleResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserScheduleResponseValidationError) ErrorName() string {
	return "UserScheduleResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UserScheduleResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserScheduleResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserScheduleResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserScheduleResponseValidationError{}

var _UserScheduleResponse_Role_InLookup = map[string]struct{}{
	"lecturer": {},
	"student":  {},
	"admin":    {},
}

// Validate checks the field values on StudentDefScheduleResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StudentDefScheduleResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StudentDefScheduleResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StudentDefScheduleResponseMultiError, or nil if none found.
func (m *StudentDefScheduleResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *StudentDefScheduleResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetInfor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StudentDefScheduleResponseValidationError{
					field:  "Infor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StudentDefScheduleResponseValidationError{
					field:  "Infor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInfor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StudentDefScheduleResponseValidationError{
				field:  "Infor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInstructor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StudentDefScheduleResponseValidationError{
					field:  "Instructor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StudentDefScheduleResponseValidationError{
					field:  "Instructor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInstructor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StudentDefScheduleResponseValidationError{
				field:  "Instructor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StudentDefScheduleResponseValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StudentDefScheduleResponseValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StudentDefScheduleResponseValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return StudentDefScheduleResponseMultiError(errors)
	}

	return nil
}

// StudentDefScheduleResponseMultiError is an error wrapping multiple
// validation errors returned by StudentDefScheduleResponse.ValidateAll() if
// the designated constraints aren't met.
type StudentDefScheduleResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StudentDefScheduleResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StudentDefScheduleResponseMultiError) AllErrors() []error { return m }

// StudentDefScheduleResponseValidationError is the validation error returned
// by StudentDefScheduleResponse.Validate if the designated constraints aren't met.
type StudentDefScheduleResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StudentDefScheduleResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StudentDefScheduleResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StudentDefScheduleResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StudentDefScheduleResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StudentDefScheduleResponseValidationError) ErrorName() string {
	return "StudentDefScheduleResponseValidationError"
}

// Error satisfies the builtin error interface
func (e StudentDefScheduleResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStudentDefScheduleResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StudentDefScheduleResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StudentDefScheduleResponseValidationError{}

// Validate checks the field values on TimeSlot with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TimeSlot) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TimeSlot with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TimeSlotMultiError, or nil
// if none found.
func (m *TimeSlot) ValidateAll() error {
	return m.validate(true)
}

func (m *TimeSlot) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Date

	// no validation rules for Shift

	// no validation rules for Id

	// no validation rules for Time

	if len(errors) > 0 {
		return TimeSlotMultiError(errors)
	}

	return nil
}

// TimeSlotMultiError is an error wrapping multiple validation errors returned
// by TimeSlot.ValidateAll() if the designated constraints aren't met.
type TimeSlotMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TimeSlotMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TimeSlotMultiError) AllErrors() []error { return m }

// TimeSlotValidationError is the validation error returned by
// TimeSlot.Validate if the designated constraints aren't met.
type TimeSlotValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TimeSlotValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TimeSlotValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TimeSlotValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TimeSlotValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TimeSlotValidationError) ErrorName() string { return "TimeSlotValidationError" }

// Error satisfies the builtin error interface
func (e TimeSlotValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTimeSlot.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TimeSlotValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TimeSlotValidationError{}

// Validate checks the field values on RoomSchedule with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RoomSchedule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RoomSchedule with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RoomScheduleMultiError, or
// nil if none found.
func (m *RoomSchedule) ValidateAll() error {
	return m.validate(true)
}

func (m *RoomSchedule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for School

	// no validation rules for Type

	// no validation rules for Description

	if len(errors) > 0 {
		return RoomScheduleMultiError(errors)
	}

	return nil
}

// RoomScheduleMultiError is an error wrapping multiple validation errors
// returned by RoomSchedule.ValidateAll() if the designated constraints aren't met.
type RoomScheduleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RoomScheduleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RoomScheduleMultiError) AllErrors() []error { return m }

// RoomScheduleValidationError is the validation error returned by
// RoomSchedule.Validate if the designated constraints aren't met.
type RoomScheduleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RoomScheduleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RoomScheduleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RoomScheduleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RoomScheduleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RoomScheduleValidationError) ErrorName() string { return "RoomScheduleValidationError" }

// Error satisfies the builtin error interface
func (e RoomScheduleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRoomSchedule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RoomScheduleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RoomScheduleValidationError{}

// Validate checks the field values on TimeSlots with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TimeSlots) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TimeSlots with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TimeSlotsMultiError, or nil
// if none found.
func (m *TimeSlots) ValidateAll() error {
	return m.validate(true)
}

func (m *TimeSlots) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStudent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TimeSlotsValidationError{
					field:  "Student",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TimeSlotsValidationError{
					field:  "Student",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStudent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TimeSlotsValidationError{
				field:  "Student",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTimeSlot()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TimeSlotsValidationError{
					field:  "TimeSlot",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TimeSlotsValidationError{
					field:  "TimeSlot",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeSlot()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TimeSlotsValidationError{
				field:  "TimeSlot",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TimeSlotsMultiError(errors)
	}

	return nil
}

// TimeSlotsMultiError is an error wrapping multiple validation errors returned
// by TimeSlots.ValidateAll() if the designated constraints aren't met.
type TimeSlotsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TimeSlotsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TimeSlotsMultiError) AllErrors() []error { return m }

// TimeSlotsValidationError is the validation error returned by
// TimeSlots.Validate if the designated constraints aren't met.
type TimeSlotsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TimeSlotsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TimeSlotsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TimeSlotsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TimeSlotsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TimeSlotsValidationError) ErrorName() string { return "TimeSlotsValidationError" }

// Error satisfies the builtin error interface
func (e TimeSlotsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTimeSlots.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TimeSlotsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TimeSlotsValidationError{}

// Validate checks the field values on Schedule with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Schedule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Schedule with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ScheduleMultiError, or nil
// if none found.
func (m *Schedule) ValidateAll() error {
	return m.validate(true)
}

func (m *Schedule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTimeSlots() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ScheduleValidationError{
						field:  fmt.Sprintf("TimeSlots[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ScheduleValidationError{
						field:  fmt.Sprintf("TimeSlots[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ScheduleValidationError{
					field:  fmt.Sprintf("TimeSlots[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetRoom()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ScheduleValidationError{
					field:  "Room",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ScheduleValidationError{
					field:  "Room",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRoom()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ScheduleValidationError{
				field:  "Room",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ScheduleMultiError(errors)
	}

	return nil
}

// ScheduleMultiError is an error wrapping multiple validation errors returned
// by Schedule.ValidateAll() if the designated constraints aren't met.
type ScheduleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScheduleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScheduleMultiError) AllErrors() []error { return m }

// ScheduleValidationError is the validation error returned by
// Schedule.Validate if the designated constraints aren't met.
type ScheduleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScheduleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScheduleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScheduleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScheduleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScheduleValidationError) ErrorName() string { return "ScheduleValidationError" }

// Error satisfies the builtin error interface
func (e ScheduleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSchedule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScheduleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScheduleValidationError{}

// Validate checks the field values on Council with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Council) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Council with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in CouncilMultiError, or nil if none found.
func (m *Council) ValidateAll() error {
	return m.validate(true)
}

func (m *Council) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if l := utf8.RuneCountInString(m.GetClass()); l < 4 || l > 10 {
		err := CouncilValidationError{
			field:  "Class",
			reason: "value length must be between 4 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PhotoSrc

	if _, ok := _Council_Role_InLookup[m.GetRole()]; !ok {
		err := CouncilValidationError{
			field:  "Role",
			reason: "value must be in list [lecturer student admin]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 200 {
		err := CouncilValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 200 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if err := m._validateEmail(m.GetEmail()); err != nil {
		err = CouncilValidationError{
			field:  "Email",
			reason: "value must be a valid email address",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Major != nil {

		if utf8.RuneCountInString(m.GetMajor()) < 2 {
			err := CouncilValidationError{
				field:  "Major",
				reason: "value length must be at least 2 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Phone != nil {

		if l := utf8.RuneCountInString(m.GetPhone()); l < 10 || l > 11 {
			err := CouncilValidationError{
				field:  "Phone",
				reason: "value length must be between 10 and 11 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return CouncilMultiError(errors)
	}

	return nil
}

func (m *Council) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *Council) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// CouncilMultiError is an error wrapping multiple validation errors returned
// by Council.ValidateAll() if the designated constraints aren't met.
type CouncilMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CouncilMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CouncilMultiError) AllErrors() []error { return m }

// CouncilValidationError is the validation error returned by Council.Validate
// if the designated constraints aren't met.
type CouncilValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CouncilValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CouncilValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CouncilValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CouncilValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CouncilValidationError) ErrorName() string { return "CouncilValidationError" }

// Error satisfies the builtin error interface
func (e CouncilValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCouncil.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CouncilValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CouncilValidationError{}

var _Council_Role_InLookup = map[string]struct{}{
	"lecturer": {},
	"student":  {},
	"admin":    {},
}

// Validate checks the field values on Thesis with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Thesis) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Thesis with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ThesisMultiError, or nil if none found.
func (m *Thesis) ValidateAll() error {
	return m.validate(true)
}

func (m *Thesis) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSchedule()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ThesisValidationError{
					field:  "Schedule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ThesisValidationError{
					field:  "Schedule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSchedule()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ThesisValidationError{
				field:  "Schedule",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetCouncil() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ThesisValidationError{
						field:  fmt.Sprintf("Council[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ThesisValidationError{
						field:  fmt.Sprintf("Council[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ThesisValidationError{
					field:  fmt.Sprintf("Council[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Id

	if len(errors) > 0 {
		return ThesisMultiError(errors)
	}

	return nil
}

// ThesisMultiError is an error wrapping multiple validation errors returned by
// Thesis.ValidateAll() if the designated constraints aren't met.
type ThesisMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ThesisMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ThesisMultiError) AllErrors() []error { return m }

// ThesisValidationError is the validation error returned by Thesis.Validate if
// the designated constraints aren't met.
type ThesisValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ThesisValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ThesisValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ThesisValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ThesisValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ThesisValidationError) ErrorName() string { return "ThesisValidationError" }

// Error satisfies the builtin error interface
func (e ThesisValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sThesis.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ThesisValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ThesisValidationError{}

// Validate checks the field values on ScheduleResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ScheduleResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ScheduleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ScheduleResponseMultiError, or nil if none found.
func (m *ScheduleResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ScheduleResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetThesis()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ScheduleResponseValidationError{
					field:  "Thesis",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ScheduleResponseValidationError{
					field:  "Thesis",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetThesis()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ScheduleResponseValidationError{
				field:  "Thesis",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ScheduleResponseValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ScheduleResponseValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ScheduleResponseValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ScheduleResponseMultiError(errors)
	}

	return nil
}

// ScheduleResponseMultiError is an error wrapping multiple validation errors
// returned by ScheduleResponse.ValidateAll() if the designated constraints
// aren't met.
type ScheduleResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScheduleResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScheduleResponseMultiError) AllErrors() []error { return m }

// ScheduleResponseValidationError is the validation error returned by
// ScheduleResponse.Validate if the designated constraints aren't met.
type ScheduleResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScheduleResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScheduleResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScheduleResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScheduleResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScheduleResponseValidationError) ErrorName() string { return "ScheduleResponseValidationError" }

// Error satisfies the builtin error interface
func (e ScheduleResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScheduleResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScheduleResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScheduleResponseValidationError{}

// Validate checks the field values on GetSchedulesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSchedulesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSchedulesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSchedulesRequestMultiError, or nil if none found.
func (m *GetSchedulesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSchedulesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetSchedulesRequestMultiError(errors)
	}

	return nil
}

// GetSchedulesRequestMultiError is an error wrapping multiple validation
// errors returned by GetSchedulesRequest.ValidateAll() if the designated
// constraints aren't met.
type GetSchedulesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSchedulesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSchedulesRequestMultiError) AllErrors() []error { return m }

// GetSchedulesRequestValidationError is the validation error returned by
// GetSchedulesRequest.Validate if the designated constraints aren't met.
type GetSchedulesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSchedulesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSchedulesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSchedulesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSchedulesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSchedulesRequestValidationError) ErrorName() string {
	return "GetSchedulesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetSchedulesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSchedulesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSchedulesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSchedulesRequestValidationError{}

// Validate checks the field values on GetSchedulesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSchedulesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSchedulesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSchedulesResponseMultiError, or nil if none found.
func (m *GetSchedulesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSchedulesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetThesis() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetSchedulesResponseValidationError{
						field:  fmt.Sprintf("Thesis[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetSchedulesResponseValidationError{
						field:  fmt.Sprintf("Thesis[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetSchedulesResponseValidationError{
					field:  fmt.Sprintf("Thesis[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetSchedulesResponseMultiError(errors)
	}

	return nil
}

// GetSchedulesResponseMultiError is an error wrapping multiple validation
// errors returned by GetSchedulesResponse.ValidateAll() if the designated
// constraints aren't met.
type GetSchedulesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSchedulesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSchedulesResponseMultiError) AllErrors() []error { return m }

// GetSchedulesResponseValidationError is the validation error returned by
// GetSchedulesResponse.Validate if the designated constraints aren't met.
type GetSchedulesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSchedulesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSchedulesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSchedulesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSchedulesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSchedulesResponseValidationError) ErrorName() string {
	return "GetSchedulesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetSchedulesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSchedulesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSchedulesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSchedulesResponseValidationError{}

// Validate checks the field values on CreateScheduleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateScheduleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateScheduleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateScheduleRequestMultiError, or nil if none found.
func (m *CreateScheduleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateScheduleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetStartDate()) < 4 {
		err := CreateScheduleRequestValidationError{
			field:  "StartDate",
			reason: "value length must be at least 4 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetQuantityWeek() < 1 {
		err := CreateScheduleRequestValidationError{
			field:  "QuantityWeek",
			reason: "value must be greater than or equal to 1",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CreateScheduleRequestMultiError(errors)
	}

	return nil
}

// CreateScheduleRequestMultiError is an error wrapping multiple validation
// errors returned by CreateScheduleRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateScheduleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateScheduleRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateScheduleRequestMultiError) AllErrors() []error { return m }

// CreateScheduleRequestValidationError is the validation error returned by
// CreateScheduleRequest.Validate if the designated constraints aren't met.
type CreateScheduleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateScheduleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateScheduleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateScheduleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateScheduleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateScheduleRequestValidationError) ErrorName() string {
	return "CreateScheduleRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateScheduleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateScheduleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateScheduleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateScheduleRequestValidationError{}

// Validate checks the field values on CreateScheduleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateScheduleResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateScheduleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateScheduleResponseMultiError, or nil if none found.
func (m *CreateScheduleResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateScheduleResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetThesis() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateScheduleResponseValidationError{
						field:  fmt.Sprintf("Thesis[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateScheduleResponseValidationError{
						field:  fmt.Sprintf("Thesis[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateScheduleResponseValidationError{
					field:  fmt.Sprintf("Thesis[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateScheduleResponseMultiError(errors)
	}

	return nil
}

// CreateScheduleResponseMultiError is an error wrapping multiple validation
// errors returned by CreateScheduleResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateScheduleResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateScheduleResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateScheduleResponseMultiError) AllErrors() []error { return m }

// CreateScheduleResponseValidationError is the validation error returned by
// CreateScheduleResponse.Validate if the designated constraints aren't met.
type CreateScheduleResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateScheduleResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateScheduleResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateScheduleResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateScheduleResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateScheduleResponseValidationError) ErrorName() string {
	return "CreateScheduleResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateScheduleResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateScheduleResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateScheduleResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateScheduleResponseValidationError{}
