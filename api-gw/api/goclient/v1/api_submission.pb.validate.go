// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: api_submission.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on CommonSubmissionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CommonSubmissionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CommonSubmissionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CommonSubmissionResponseMultiError, or nil if none found.
func (m *CommonSubmissionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CommonSubmissionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetStatusCode() < 1 {
		err := CommonSubmissionResponseValidationError{
			field:  "StatusCode",
			reason: "value must be greater than or equal to 1",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetMessage()) < 2 {
		err := CommonSubmissionResponseValidationError{
			field:  "Message",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CommonSubmissionResponseMultiError(errors)
	}

	return nil
}

// CommonSubmissionResponseMultiError is an error wrapping multiple validation
// errors returned by CommonSubmissionResponse.ValidateAll() if the designated
// constraints aren't met.
type CommonSubmissionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CommonSubmissionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CommonSubmissionResponseMultiError) AllErrors() []error { return m }

// CommonSubmissionResponseValidationError is the validation error returned by
// CommonSubmissionResponse.Validate if the designated constraints aren't met.
type CommonSubmissionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CommonSubmissionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CommonSubmissionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CommonSubmissionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CommonSubmissionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CommonSubmissionResponseValidationError) ErrorName() string {
	return "CommonSubmissionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CommonSubmissionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCommonSubmissionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CommonSubmissionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CommonSubmissionResponseValidationError{}

// Validate checks the field values on SubmissionInput with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SubmissionInput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubmissionInput with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubmissionInputMultiError, or nil if none found.
func (m *SubmissionInput) ValidateAll() error {
	return m.validate(true)
}

func (m *SubmissionInput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserID

	if m.GetExerciseID() < 1 {
		err := SubmissionInputValidationError{
			field:  "ExerciseID",
			reason: "value must be greater than or equal to 1",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSubmissionDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SubmissionInputValidationError{
					field:  "SubmissionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SubmissionInputValidationError{
					field:  "SubmissionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubmissionDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SubmissionInputValidationError{
				field:  "SubmissionDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetStatus()) < 2 {
		err := SubmissionInputValidationError{
			field:  "Status",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetAttachments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SubmissionInputValidationError{
						field:  fmt.Sprintf("Attachments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SubmissionInputValidationError{
						field:  fmt.Sprintf("Attachments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SubmissionInputValidationError{
					field:  fmt.Sprintf("Attachments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SubmissionInputMultiError(errors)
	}

	return nil
}

// SubmissionInputMultiError is an error wrapping multiple validation errors
// returned by SubmissionInput.ValidateAll() if the designated constraints
// aren't met.
type SubmissionInputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubmissionInputMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubmissionInputMultiError) AllErrors() []error { return m }

// SubmissionInputValidationError is the validation error returned by
// SubmissionInput.Validate if the designated constraints aren't met.
type SubmissionInputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubmissionInputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubmissionInputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubmissionInputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubmissionInputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubmissionInputValidationError) ErrorName() string { return "SubmissionInputValidationError" }

// Error satisfies the builtin error interface
func (e SubmissionInputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubmissionInput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubmissionInputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubmissionInputValidationError{}

// Validate checks the field values on AttachmentSubmissionInput with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AttachmentSubmissionInput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AttachmentSubmissionInput with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AttachmentSubmissionInputMultiError, or nil if none found.
func (m *AttachmentSubmissionInput) ValidateAll() error {
	return m.validate(true)
}

func (m *AttachmentSubmissionInput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FileURL

	// no validation rules for Status

	// no validation rules for SubmissionID

	// no validation rules for ExerciseID

	// no validation rules for AuthorID

	if len(errors) > 0 {
		return AttachmentSubmissionInputMultiError(errors)
	}

	return nil
}

// AttachmentSubmissionInputMultiError is an error wrapping multiple validation
// errors returned by AttachmentSubmissionInput.ValidateAll() if the
// designated constraints aren't met.
type AttachmentSubmissionInputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AttachmentSubmissionInputMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AttachmentSubmissionInputMultiError) AllErrors() []error { return m }

// AttachmentSubmissionInputValidationError is the validation error returned by
// AttachmentSubmissionInput.Validate if the designated constraints aren't met.
type AttachmentSubmissionInputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AttachmentSubmissionInputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AttachmentSubmissionInputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AttachmentSubmissionInputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AttachmentSubmissionInputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AttachmentSubmissionInputValidationError) ErrorName() string {
	return "AttachmentSubmissionInputValidationError"
}

// Error satisfies the builtin error interface
func (e AttachmentSubmissionInputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAttachmentSubmissionInput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AttachmentSubmissionInputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AttachmentSubmissionInputValidationError{}

// Validate checks the field values on SubmissionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubmissionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubmissionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubmissionResponseMultiError, or nil if none found.
func (m *SubmissionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SubmissionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() < 1 {
		err := SubmissionResponseValidationError{
			field:  "Id",
			reason: "value must be greater than or equal to 1",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for UserID

	if m.GetExerciseID() < 1 {
		err := SubmissionResponseValidationError{
			field:  "ExerciseID",
			reason: "value must be greater than or equal to 1",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSubmissionDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SubmissionResponseValidationError{
					field:  "SubmissionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SubmissionResponseValidationError{
					field:  "SubmissionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubmissionDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SubmissionResponseValidationError{
				field:  "SubmissionDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetStatus()) < 2 {
		err := SubmissionResponseValidationError{
			field:  "Status",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetAttachments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SubmissionResponseValidationError{
						field:  fmt.Sprintf("Attachments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SubmissionResponseValidationError{
						field:  fmt.Sprintf("Attachments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SubmissionResponseValidationError{
					field:  fmt.Sprintf("Attachments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SubmissionResponseMultiError(errors)
	}

	return nil
}

// SubmissionResponseMultiError is an error wrapping multiple validation errors
// returned by SubmissionResponse.ValidateAll() if the designated constraints
// aren't met.
type SubmissionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubmissionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubmissionResponseMultiError) AllErrors() []error { return m }

// SubmissionResponseValidationError is the validation error returned by
// SubmissionResponse.Validate if the designated constraints aren't met.
type SubmissionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubmissionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubmissionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubmissionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubmissionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubmissionResponseValidationError) ErrorName() string {
	return "SubmissionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SubmissionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubmissionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubmissionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubmissionResponseValidationError{}

// Validate checks the field values on AttachmentSubmissionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AttachmentSubmissionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AttachmentSubmissionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AttachmentSubmissionResponseMultiError, or nil if none found.
func (m *AttachmentSubmissionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AttachmentSubmissionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for FileURL

	// no validation rules for Status

	if len(errors) > 0 {
		return AttachmentSubmissionResponseMultiError(errors)
	}

	return nil
}

// AttachmentSubmissionResponseMultiError is an error wrapping multiple
// validation errors returned by AttachmentSubmissionResponse.ValidateAll() if
// the designated constraints aren't met.
type AttachmentSubmissionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AttachmentSubmissionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AttachmentSubmissionResponseMultiError) AllErrors() []error { return m }

// AttachmentSubmissionResponseValidationError is the validation error returned
// by AttachmentSubmissionResponse.Validate if the designated constraints
// aren't met.
type AttachmentSubmissionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AttachmentSubmissionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AttachmentSubmissionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AttachmentSubmissionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AttachmentSubmissionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AttachmentSubmissionResponseValidationError) ErrorName() string {
	return "AttachmentSubmissionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AttachmentSubmissionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAttachmentSubmissionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AttachmentSubmissionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AttachmentSubmissionResponseValidationError{}

// Validate checks the field values on CreateSubmissionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateSubmissionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateSubmissionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateSubmissionRequestMultiError, or nil if none found.
func (m *CreateSubmissionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateSubmissionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetSubmission() == nil {
		err := CreateSubmissionRequestValidationError{
			field:  "Submission",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSubmission()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateSubmissionRequestValidationError{
					field:  "Submission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateSubmissionRequestValidationError{
					field:  "Submission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubmission()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateSubmissionRequestValidationError{
				field:  "Submission",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateSubmissionRequestMultiError(errors)
	}

	return nil
}

// CreateSubmissionRequestMultiError is an error wrapping multiple validation
// errors returned by CreateSubmissionRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateSubmissionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateSubmissionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateSubmissionRequestMultiError) AllErrors() []error { return m }

// CreateSubmissionRequestValidationError is the validation error returned by
// CreateSubmissionRequest.Validate if the designated constraints aren't met.
type CreateSubmissionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateSubmissionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateSubmissionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateSubmissionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateSubmissionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateSubmissionRequestValidationError) ErrorName() string {
	return "CreateSubmissionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateSubmissionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateSubmissionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateSubmissionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateSubmissionRequestValidationError{}

// Validate checks the field values on CreateSubmissionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateSubmissionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateSubmissionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateSubmissionResponseMultiError, or nil if none found.
func (m *CreateSubmissionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateSubmissionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetResponse() == nil {
		err := CreateSubmissionResponseValidationError{
			field:  "Response",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetResponse()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateSubmissionResponseValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateSubmissionResponseValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResponse()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateSubmissionResponseValidationError{
				field:  "Response",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateSubmissionResponseMultiError(errors)
	}

	return nil
}

// CreateSubmissionResponseMultiError is an error wrapping multiple validation
// errors returned by CreateSubmissionResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateSubmissionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateSubmissionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateSubmissionResponseMultiError) AllErrors() []error { return m }

// CreateSubmissionResponseValidationError is the validation error returned by
// CreateSubmissionResponse.Validate if the designated constraints aren't met.
type CreateSubmissionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateSubmissionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateSubmissionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateSubmissionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateSubmissionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateSubmissionResponseValidationError) ErrorName() string {
	return "CreateSubmissionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateSubmissionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateSubmissionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateSubmissionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateSubmissionResponseValidationError{}

// Validate checks the field values on GetSubmissionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSubmissionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSubmissionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSubmissionRequestMultiError, or nil if none found.
func (m *GetSubmissionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSubmissionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() < 1 {
		err := GetSubmissionRequestValidationError{
			field:  "Id",
			reason: "value must be greater than or equal to 1",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetSubmissionRequestMultiError(errors)
	}

	return nil
}

// GetSubmissionRequestMultiError is an error wrapping multiple validation
// errors returned by GetSubmissionRequest.ValidateAll() if the designated
// constraints aren't met.
type GetSubmissionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSubmissionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSubmissionRequestMultiError) AllErrors() []error { return m }

// GetSubmissionRequestValidationError is the validation error returned by
// GetSubmissionRequest.Validate if the designated constraints aren't met.
type GetSubmissionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSubmissionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSubmissionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSubmissionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSubmissionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSubmissionRequestValidationError) ErrorName() string {
	return "GetSubmissionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetSubmissionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSubmissionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSubmissionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSubmissionRequestValidationError{}

// Validate checks the field values on GetSubmissionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSubmissionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSubmissionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSubmissionResponseMultiError, or nil if none found.
func (m *GetSubmissionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSubmissionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetResponse() == nil {
		err := GetSubmissionResponseValidationError{
			field:  "Response",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetResponse()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetSubmissionResponseValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetSubmissionResponseValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResponse()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetSubmissionResponseValidationError{
				field:  "Response",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetSubmission() == nil {
		err := GetSubmissionResponseValidationError{
			field:  "Submission",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSubmission()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetSubmissionResponseValidationError{
					field:  "Submission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetSubmissionResponseValidationError{
					field:  "Submission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubmission()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetSubmissionResponseValidationError{
				field:  "Submission",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetSubmissionResponseMultiError(errors)
	}

	return nil
}

// GetSubmissionResponseMultiError is an error wrapping multiple validation
// errors returned by GetSubmissionResponse.ValidateAll() if the designated
// constraints aren't met.
type GetSubmissionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSubmissionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSubmissionResponseMultiError) AllErrors() []error { return m }

// GetSubmissionResponseValidationError is the validation error returned by
// GetSubmissionResponse.Validate if the designated constraints aren't met.
type GetSubmissionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSubmissionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSubmissionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSubmissionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSubmissionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSubmissionResponseValidationError) ErrorName() string {
	return "GetSubmissionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetSubmissionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSubmissionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSubmissionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSubmissionResponseValidationError{}

// Validate checks the field values on UpdateSubmissionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateSubmissionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateSubmissionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateSubmissionRequestMultiError, or nil if none found.
func (m *UpdateSubmissionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateSubmissionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() < 1 {
		err := UpdateSubmissionRequestValidationError{
			field:  "Id",
			reason: "value must be greater than or equal to 1",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSubmission() == nil {
		err := UpdateSubmissionRequestValidationError{
			field:  "Submission",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSubmission()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateSubmissionRequestValidationError{
					field:  "Submission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateSubmissionRequestValidationError{
					field:  "Submission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubmission()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateSubmissionRequestValidationError{
				field:  "Submission",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateSubmissionRequestMultiError(errors)
	}

	return nil
}

// UpdateSubmissionRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateSubmissionRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateSubmissionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateSubmissionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateSubmissionRequestMultiError) AllErrors() []error { return m }

// UpdateSubmissionRequestValidationError is the validation error returned by
// UpdateSubmissionRequest.Validate if the designated constraints aren't met.
type UpdateSubmissionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateSubmissionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateSubmissionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateSubmissionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateSubmissionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateSubmissionRequestValidationError) ErrorName() string {
	return "UpdateSubmissionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateSubmissionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateSubmissionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateSubmissionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateSubmissionRequestValidationError{}

// Validate checks the field values on UpdateSubmissionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateSubmissionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateSubmissionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateSubmissionResponseMultiError, or nil if none found.
func (m *UpdateSubmissionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateSubmissionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetResponse() == nil {
		err := UpdateSubmissionResponseValidationError{
			field:  "Response",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetResponse()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateSubmissionResponseValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateSubmissionResponseValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResponse()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateSubmissionResponseValidationError{
				field:  "Response",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateSubmissionResponseMultiError(errors)
	}

	return nil
}

// UpdateSubmissionResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateSubmissionResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateSubmissionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateSubmissionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateSubmissionResponseMultiError) AllErrors() []error { return m }

// UpdateSubmissionResponseValidationError is the validation error returned by
// UpdateSubmissionResponse.Validate if the designated constraints aren't met.
type UpdateSubmissionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateSubmissionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateSubmissionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateSubmissionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateSubmissionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateSubmissionResponseValidationError) ErrorName() string {
	return "UpdateSubmissionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateSubmissionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateSubmissionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateSubmissionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateSubmissionResponseValidationError{}

// Validate checks the field values on DeleteSubmissionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteSubmissionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteSubmissionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteSubmissionRequestMultiError, or nil if none found.
func (m *DeleteSubmissionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteSubmissionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() < 1 {
		err := DeleteSubmissionRequestValidationError{
			field:  "Id",
			reason: "value must be greater than or equal to 1",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteSubmissionRequestMultiError(errors)
	}

	return nil
}

// DeleteSubmissionRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteSubmissionRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteSubmissionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteSubmissionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteSubmissionRequestMultiError) AllErrors() []error { return m }

// DeleteSubmissionRequestValidationError is the validation error returned by
// DeleteSubmissionRequest.Validate if the designated constraints aren't met.
type DeleteSubmissionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteSubmissionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteSubmissionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteSubmissionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteSubmissionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteSubmissionRequestValidationError) ErrorName() string {
	return "DeleteSubmissionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteSubmissionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteSubmissionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteSubmissionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteSubmissionRequestValidationError{}

// Validate checks the field values on DeleteSubmissionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteSubmissionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteSubmissionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteSubmissionResponseMultiError, or nil if none found.
func (m *DeleteSubmissionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteSubmissionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetResponse() == nil {
		err := DeleteSubmissionResponseValidationError{
			field:  "Response",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetResponse()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteSubmissionResponseValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteSubmissionResponseValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResponse()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteSubmissionResponseValidationError{
				field:  "Response",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteSubmissionResponseMultiError(errors)
	}

	return nil
}

// DeleteSubmissionResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteSubmissionResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteSubmissionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteSubmissionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteSubmissionResponseMultiError) AllErrors() []error { return m }

// DeleteSubmissionResponseValidationError is the validation error returned by
// DeleteSubmissionResponse.Validate if the designated constraints aren't met.
type DeleteSubmissionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteSubmissionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteSubmissionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteSubmissionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteSubmissionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteSubmissionResponseValidationError) ErrorName() string {
	return "DeleteSubmissionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteSubmissionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteSubmissionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteSubmissionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteSubmissionResponseValidationError{}

// Validate checks the field values on GetAllSubmissionsOfExerciseRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetAllSubmissionsOfExerciseRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAllSubmissionsOfExerciseRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetAllSubmissionsOfExerciseRequestMultiError, or nil if none found.
func (m *GetAllSubmissionsOfExerciseRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAllSubmissionsOfExerciseRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetExerciseID() < 1 {
		err := GetAllSubmissionsOfExerciseRequestValidationError{
			field:  "ExerciseID",
			reason: "value must be greater than or equal to 1",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetAllSubmissionsOfExerciseRequestMultiError(errors)
	}

	return nil
}

// GetAllSubmissionsOfExerciseRequestMultiError is an error wrapping multiple
// validation errors returned by
// GetAllSubmissionsOfExerciseRequest.ValidateAll() if the designated
// constraints aren't met.
type GetAllSubmissionsOfExerciseRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAllSubmissionsOfExerciseRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAllSubmissionsOfExerciseRequestMultiError) AllErrors() []error { return m }

// GetAllSubmissionsOfExerciseRequestValidationError is the validation error
// returned by GetAllSubmissionsOfExerciseRequest.Validate if the designated
// constraints aren't met.
type GetAllSubmissionsOfExerciseRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAllSubmissionsOfExerciseRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAllSubmissionsOfExerciseRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAllSubmissionsOfExerciseRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAllSubmissionsOfExerciseRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAllSubmissionsOfExerciseRequestValidationError) ErrorName() string {
	return "GetAllSubmissionsOfExerciseRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetAllSubmissionsOfExerciseRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAllSubmissionsOfExerciseRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAllSubmissionsOfExerciseRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAllSubmissionsOfExerciseRequestValidationError{}

// Validate checks the field values on GetAllSubmissionsOfExerciseResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetAllSubmissionsOfExerciseResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAllSubmissionsOfExerciseResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetAllSubmissionsOfExerciseResponseMultiError, or nil if none found.
func (m *GetAllSubmissionsOfExerciseResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAllSubmissionsOfExerciseResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetResponse() == nil {
		err := GetAllSubmissionsOfExerciseResponseValidationError{
			field:  "Response",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetResponse()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetAllSubmissionsOfExerciseResponseValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetAllSubmissionsOfExerciseResponseValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResponse()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetAllSubmissionsOfExerciseResponseValidationError{
				field:  "Response",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetTotalCount() < 0 {
		err := GetAllSubmissionsOfExerciseResponseValidationError{
			field:  "TotalCount",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetSubmissions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetAllSubmissionsOfExerciseResponseValidationError{
						field:  fmt.Sprintf("Submissions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetAllSubmissionsOfExerciseResponseValidationError{
						field:  fmt.Sprintf("Submissions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetAllSubmissionsOfExerciseResponseValidationError{
					field:  fmt.Sprintf("Submissions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetAllSubmissionsOfExerciseResponseMultiError(errors)
	}

	return nil
}

// GetAllSubmissionsOfExerciseResponseMultiError is an error wrapping multiple
// validation errors returned by
// GetAllSubmissionsOfExerciseResponse.ValidateAll() if the designated
// constraints aren't met.
type GetAllSubmissionsOfExerciseResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAllSubmissionsOfExerciseResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAllSubmissionsOfExerciseResponseMultiError) AllErrors() []error { return m }

// GetAllSubmissionsOfExerciseResponseValidationError is the validation error
// returned by GetAllSubmissionsOfExerciseResponse.Validate if the designated
// constraints aren't met.
type GetAllSubmissionsOfExerciseResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAllSubmissionsOfExerciseResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAllSubmissionsOfExerciseResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAllSubmissionsOfExerciseResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAllSubmissionsOfExerciseResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAllSubmissionsOfExerciseResponseValidationError) ErrorName() string {
	return "GetAllSubmissionsOfExerciseResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetAllSubmissionsOfExerciseResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAllSubmissionsOfExerciseResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAllSubmissionsOfExerciseResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAllSubmissionsOfExerciseResponseValidationError{}
